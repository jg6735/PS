# **ë²½ëŒ ê¹¨ê¸°**
### ğŸ“Œ [ëª¨ì˜SWì—­ëŸ‰í…ŒìŠ¤íŠ¸ ë²½ëŒ ê¹¨ê¸°](https://swexpertacademy.com/main/main.do)
-------------
### **âœ” í’€ì´ ê³¼ì • / í•™ìŠµí•œ ë‚´ìš©**
- êµ¬í˜„, ì‹œë®¬ë ˆì´ì…˜, ìˆœì—´, BFS ì—¬ëŸ¬ê°€ì§€ë¥¼ ì ‘ëª©í•´ì„œ í’€ì–´ì•¼í•˜ëŠ” ì–´ë ¤ìš´ ë¬¸ì œì˜€ë‹¤... 
1. ê°™ì€ ìœ„ì¹˜ì— ì˜ë”ë¼ë„ ìˆœì„œì— ë”°ë¼ ë‚¨ëŠ” ë²½ëŒì˜ ê°œìˆ˜ê°€ ë‹¬ë¼ì§€ê¸° ë•Œë¬¸ì— êµ¬ìŠ¬ ìœ„ì¹˜ëŠ” ì¤‘ë³µ ìˆœì—´ë¡œ êµ¬í•œë‹¤.
2. 1ì€ ìê¸° ìì‹ ë§Œ í„°ì§€ë¯€ë¡œ 1ë³´ë‹¤ í° ê²½ìš°ë§Œ BFSë¡œ ì—°ì‡„ì ìœ¼ë¡œ í„°ëœ¨ë¦¬ë„ë¡ í–ˆë‹¤. ë°©ë¬¸ì²˜ë¦¬ëŠ” ë¹ˆì¹¸ìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒê³¼ í•¨ê»˜ í•´ë‹¹ ë°°ì—´ì˜ ê°’ì„ 0ìœ¼ë¡œ ë§Œë“¤ì—ˆë‹¤.
3. ë²½ëŒì„ ë¶€ìˆœ ë’¤ ê³µì¤‘ì— ë– ìˆê³  ë‚¨ì€ ë²½ëŒë“¤ì„ íì— ì €ì¥í•˜ê³  ì €ì¥ëœ ìˆœì„œëŒ€ë¡œ ë§¨ ë°‘ì—ì„œë¶€í„° ì •ë ¬í–ˆë‹¤.
4. BFSê°€ ëë‚˜ê³  ë‚¨ì€ ë²½ëŒ ì¤‘ ìµœì†Ÿê°’ì„ êµ¬í•´ ì¶œë ¥í•œë‹¤.   
- ë‹¤ì‹œ í’€ì–´ë„ ì‹œê°„ì•ˆì— ìˆœì„œëŒ€ë¡œ ì°¨ê·¼ì°¨ê·¼ í’€ ìˆ˜ ìˆë„ë¡ ë” ì˜ ì •ë¦¬í•˜ê³  ê³µë¶€í•´ì•¼ê² ë‹¤. 
-------------
### **ì½”ë“œ**
```java
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;
import java.util.StringTokenizer;

public class SW_5656_ë²½ëŒê¹¨ê¸° {

	static class Point {
		private int row;
		private int column;
		private int count;

		public Point(int row, int column, int count) {
			this.row = row;
			this.column = column;
			this.count = count;
		}

		public int getRow() {
			return row;
		}

		public int getColumn() {
			return column;
		}

		public int getCount() {
			return count;
		}
	}

	private static int[] dr = { -1, 0, 1, 0 };
	private static int[] dc = { 0, 1, 0, -1 };
	private static int min;

	public static void main(String[] args) throws IOException {
		System.setIn(new FileInputStream("input_SW_5656_ë²½ëŒê¹¨ê¸°.txt"));
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		StringTokenizer st;

		int T = Integer.parseInt(br.readLine());
		for (int tc = 1; tc <= T; tc++) {
			st = new StringTokenizer(br.readLine(), " ");

			int N = Integer.parseInt(st.nextToken()); // êµ¬ìŠ¬ ì˜ëŠ” íšŸìˆ˜
			int W = Integer.parseInt(st.nextToken()); // ê°€ë¡œê¸¸ì´
			int H = Integer.parseInt(st.nextToken()); // ì„¸ë¡œê¸¸ì´
			int[][] map = new int[H][W];
			min = Integer.MAX_VALUE;

			for (int i = 0; i < H; i++) {
				st = new StringTokenizer(br.readLine(), " ");
				for (int j = 0; j < W; j++) {
					map[i][j] = Integer.parseInt(st.nextToken());
				}
			}

			shoot(map, 0, N);

			sb.append("#").append(tc).append(" ").append(min).append("\n");
		}

		System.out.print(sb);
	}

	// ë§µì˜ ì—´ì— ì¤‘ë³µ ìˆœì—´ì„ ì´ìš©í•´ì„œ êµ¬ìŠ¬ ì˜ê¸° ë©”ì„œë“œ
	private static boolean shoot(int[][] map, int count, int N) {
		int remain = getRemain(map);

		if (remain == 0) {
			min = 0;
			return true;
		}

		if (count == N) {
			min = Math.min(min, remain);
			return false;
		}

		for (int column = 0; column < map[0].length; column++) {
			int row = 0;

			while (row < map.length && map[row][column] == 0) {
				row++;
			}

			if (row == map.length) {
				continue;
			}

			int[][] copiedMap = copy(map);
			breakout(copiedMap, row, column);
			sort(copiedMap);
			if(shoot(copiedMap, count + 1, N)) return true;
		}
		
		return false;
	}

	// ë²½ëŒ ê¹¨ê¸° ë©”ì„œë“œ BFS
	private static void breakout(int[][] map, int row, int column) {
		Queue<Point> queue = new LinkedList<Point>();
		if (map[row][column] > 1) {
			queue.offer(new Point(row, column, map[row][column]));
		}

		map[row][column] = 0;

		Point cur;
		int curRow, curColumn, curCount;
		while (!queue.isEmpty()) {
			cur = queue.poll();
			curRow = cur.getRow();
			curColumn = cur.getColumn();
			curCount = cur.getCount();

			for (int d = 0; d < 4; d++) {
				int nextRow = curRow;
				int nextColumn = curColumn;
				
				for (int i = 1; i < curCount; i++) {
					nextRow += dr[d];
					nextColumn += dc[d];
					
					if (!check(map, nextRow, nextColumn)) {
						continue;
					}

					if (map[nextRow][nextColumn] == 0) {
						continue;
					}

					if (map[nextRow][nextColumn] > 1) {
						queue.offer(new Point(nextRow, nextColumn, map[nextRow][nextColumn]));
					}

					map[nextRow][nextColumn] = 0;
				}
			}
		}
	}

	// ë¶€ìˆœ ë’¤ ë‚¨ì€ ë²½ëŒ ì •ë¦¬ ë©”ì„œë“œ
	private static void sort(int[][] map) {
		for (int column = 0; column < map[0].length; column++) {
			Queue<Integer> queue = new LinkedList<Integer>();
			for (int row = map.length - 1; row >= 0; row--) {
				if (map[row][column] > 0) {
					queue.offer(map[row][column]);
					map[row][column] = 0;
				}
			}
			
			int row = map.length - 1;
			while (!queue.isEmpty()) {
				map[row][column] = queue.poll();
				row--;
			}
		}
	}

	// ë‚¨ì•„ìˆëŠ” ë²½ëŒ ê°¯ìˆ˜ë¥¼ êµ¬í•˜ê¸° ë©”ì„œë“œ
	private static int getRemain(int[][] map) {
		int count = 0;

		for (int i = 0; i < map.length; i++) {
			for (int j = 0; j < map[i].length; j++) {
				if (map[i][j] == 0) {
					continue;
				}
				count++;
			}
		}

		return count;
	}

	// ì¤‘ë³µ ìˆœì—´ì˜ ê° ìƒí™©ì„ ë”°ì ¸ë³´ê¸° ìœ„í•œ ë°°ì—´ ë³µì‚¬ ë©”ì„œë“œ
	private static int[][] copy(int[][] map) {
		int[][] copiedMap = new int[map.length][map[0].length];

		for (int i = 0; i < map.length; i++) {
			System.arraycopy(map[i], 0, copiedMap[i], 0, copiedMap[i].length);
		}

		return copiedMap;
	}

	// ë°°ì—´ ë²”ìœ„ ì²´í¬ ë©”ì„œë“œ
	private static boolean check(int[][] map, int row, int column) {
		if (row < 0 || row >= map.length || column < 0 || column >= map[0].length) {
			return false;
		}

		return true;
	}
}
```