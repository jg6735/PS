# **í† ë§ˆí† (2)**
### ğŸ“Œ [BOJ G5 7569 í† ë§ˆí† (2)](https://www.acmicpc.net/problem/7569)
-------------
### **âœ” í’€ì´ ê³¼ì • / í•™ìŠµí•œ ë‚´ìš©**
- ê°’ì´ 1ì¸ ê²½ìš°ë§Œ í† ë§ˆí† ì´ë¯€ë¡œ í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ê³ , BFSë¡œ ì¸ì ‘í•œ ì¹¸ì´ 0ì¼ ê²½ìš° ë‚ ì§œë¥¼ í•˜ë£¨ì”© ì¦ê°€ì‹œì¼°ë‹¤.
ê·¸ë¦¬ê³  ë¬¸ì œì˜ ì¡°ê±´ì— ë”°ë¼ ì²˜ìŒë¶€í„° í† ë§ˆí† ë¡œ ê°€ë“ì°¼ìœ¼ë©´ 0 ì¶œë ¥, ìµì§€ ì•Šì€ í† ë§ˆí† ê°€ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ -1 ì¶œë ¥, ê·¸ì™¸ì˜ ê²½ìš° ë‚ ì§œë¥¼ ì¶œë ¥í–ˆë‹¤.
ê¸°ì¡´ì˜ í† ë§ˆí†  ë¬¸ì œì—ì„œ ë†’ì´ê°€ ì¶”ê°€ë˜ì—ˆê¸° ë•Œë¬¸ì—, ë°©í–¥ê°’ê³¼ ë°°ì—´ì„ 3ì°¨ì›ìœ¼ë¡œ ë‹¤ë£¨ì–´ í•´ê²°í–ˆë‹¤.
-------------
### **ì½”ë“œ**
```java
package boj.gold;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_7569_í† ë§ˆí†  {

	static class Point {
		private int h;
		private int x;
		private int y;

		public Point(int h, int x, int y) {
			this.h = h;
			this.x = x;
			this.y = y;
		}

		public int getH() {
			return h;
		}

		public int getX() {
			return x;
		}

		public int getY() {
			return y;
		}
	}

	private static int N, M, H, count, zeroCount;
	private static int[][][] grid;
	private static ArrayList<Point> list;
	private static int[] dx = { 0, 1, 0, -1, 0, 0};
	private static int[] dy = { -1, 0, 1, 0, 0, 0};
	private static int[] dh = { 0, 0, 0, 0, -1, 1};

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");

		M = Integer.parseInt(st.nextToken());
		N = Integer.parseInt(st.nextToken());
		H = Integer.parseInt(st.nextToken());
		grid = new int[H][N][M];
		list = new ArrayList<Point>();
		count = 0;
		zeroCount = 0;

		for (int h = 0; h < H; h++) {
			for (int i = 0; i < N; i++) {
				st = new StringTokenizer(br.readLine(), " ");
				for (int j = 0; j < M; j++) {
					grid[h][i][j] = Integer.parseInt(st.nextToken());
					if (grid[h][i][j] == 1) {
						list.add(new Point(h, j, i));
					}
					if (grid[h][i][j] == 0) {
						zeroCount++;
					}
				}
			}
		}

		if (zeroCount == 0) {
			System.out.println(0);
			return;
		}

		bfs();
	}

	private static void bfs() {
		Queue<Point> queue = new LinkedList<Point>();
		for (Point p : list) {
			queue.offer(p);
		}

		Point cur;
		int x, y, h, nextX, nextY, nextH;
		while (!queue.isEmpty()) {
			cur = queue.poll();
			x = cur.getX();
			y = cur.getY();
			h = cur.getH();

			for (int d = 0; d < 6; d++) {
				nextX = x + dx[d];
				nextY = y + dy[d];
				nextH = h + dh[d];

				if (!check(nextH, nextX, nextY)) {
					continue;
				}

				if (grid[nextH][nextY][nextX] != 0) {
					continue;
				}

				grid[nextH][nextY][nextX] = grid[h][y][x] + 1;
				queue.offer(new Point(nextH, nextX, nextY));
			}
		}

		getDate();
	}

	private static void getDate() {
		for (int h = 0; h < H; h++) {
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < M; j++) {
					if (grid[h][i][j] == 0) {
						System.out.println(-1);
						return;
					}

					count = Math.max(count, grid[h][i][j]);
				}
			}
		}

		System.out.println(count - 1);
	}

	private static boolean check(int h, int x, int y) {
		if (h < 0 || h >= H || x < 0 || x >= M || y < 0 || y >= N) {
			return false;
		}

		return true;
	}
}
```