# **ì—°êµ¬ì†Œ**
### ğŸ“Œ [BOJ G5 14502 ì—°êµ¬ì†Œ](https://www.acmicpc.net/problem/14502)
-------------
### **âœ” í’€ì´ ê³¼ì • / í•™ìŠµí•œ ë‚´ìš©**
- íƒìƒ‰ê³¼ ì¡°í•© ê·¸ë¦¬ê³  ì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì˜€ëŠ”ë°, BFSë¥¼ ì´ìš©í•´ì„œ í•´ê²°í–ˆë‹¤.   
ë°°ì—´ì„ ë³µì‚¬í•´ì„œ ì‚¬ìš©í•´ì•¼ ì´ì „ì˜ ë°°ì—´ì„ ê¸°ì–µí•  ìˆ˜ ìˆì—ˆë‹¤. ë²½ì„ 3ê°œ ì„¸ì› ì„ ë•Œì˜ ì¡°í•©ì„ í†µí•´
ê°ê°ì˜ ê²½ìš°ë¥¼ íŒŒì•…í•´ì„œ ìµœëŒ€ ì•ˆì „ ì˜ì—­ì˜ ê°œìˆ˜ë¥¼ êµ¬í•  ìˆ˜ ìˆì—ˆë‹¤.
-------------
### **ì½”ë“œ**
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class BOJ_14502_ì—°êµ¬ì†Œ {

    static class Coordinates {
        private int x;
        private int y;

        public Coordinates(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }
    }

    // ì•ˆì „ ì˜ì—­ í¬ê¸° ì¶œë ¥ê°’
    static int answer;
    // ë°©í–¥ê°’
    static int[] moveX = {-1, 0, 1, 0};
    static int[] moveY = {0, 1, 0, -1};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");

        int N = Integer.parseInt(st.nextToken()); // ì„¸ë¡œ í¬ê¸°
        int M = Integer.parseInt(st.nextToken()); // ê°€ë¡œ í¬ê¸°
        answer = Integer.MIN_VALUE; // ì¶œë ¥ê°’

        int[][] graph = new int[N][M];  // ì—°êµ¬ì†Œ ë°°ì—´
        List<Coordinates> list = new ArrayList<>(); // ë°”ì´ëŸ¬ìŠ¤ ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸

        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < M; j++) {
                graph[i][j] = Integer.parseInt(st.nextToken());
                if (graph[i][j] == 2) { // ë°”ì´ëŸ¬ìŠ¤ ì¢Œí‘œ ArrayListì— ì‚½ì…
                    list.add(new Coordinates(i, j));
                }
            }
        }

        combination(graph, list, 0);
        System.out.println(answer);
    }

    // ë¹ˆ ì¹¸(0)ì¸ ê³³ë“¤ ì¤‘ ë²½ 3ê°œë¥¼ ì„¸ìš°ëŠ” ê²½ìš°ë¥¼ êµ¬í•œë‹¤.
    public static void combination(int[][] graph, List<Coordinates> list, int cnt) {
        // ê¸°ì €
        if (cnt == 3) { // ë²½ì„ 3ê°œ ì„¸ìš°ë©´
            int[][] copiedArr = copy(graph); // ì´ì „ ë°°ì—´ ë³µì‚¬í•´ì„œ í™•ì¸
            BFS(copiedArr, list); // ë°”ì´ëŸ¬ìŠ¤ ì „ì—¼ BFS
            return;
        }

        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph[i].length; j++) {
                // 0 : í•´ë‹¹ ì¢Œí‘œê°€ ë¹ˆ ì¹¸ì¼ ë•Œ
                if (graph[i][j] == 0) {
                    graph[i][j] = 1; // ë²½ ì„¸ìš°ëŠ” ê²½ìš°
                    combination(graph, list, cnt + 1);
                    graph[i][j] = 0; // ë²½ ì„¸ìš°ì§€ ì•ŠëŠ” ê²½ìš°
                }
            }
        }

    }

    // ë°°ì—´ ë³µì‚¬í•˜ê¸°
    public static int[][] copy(int[][] graph) {
        int[][] copiedArr = new int[graph.length][graph[0].length];
        for (int i = 0; i < graph.length; i++) {
            System.arraycopy(graph[i], 0, copiedArr[i], 0, graph[i].length);
        }

        // ë³µì‚¬ëœ ë°°ì—´ ë°˜í™˜
        return copiedArr;
    }

    public static void BFS(int[][] graph, List<Coordinates> list) {
        Queue<Coordinates> queue = new LinkedList<>();

        // ë°”ì´ëŸ¬ìŠ¤ë“¤ì„ íì— ì‚½ì…
        for (int i = 0; i < list.size(); i++) {
            queue.offer(list.get(i));
        }

        // íê°€ ë¹Œ ë•Œ ê¹Œì§€
        while(!queue.isEmpty()) {
            // íì—ì„œ ë°”ì´ëŸ¬ìŠ¤ë¥¼ êº¼ë‚´ì„œ
            Coordinates cur = queue.poll();
            int curX = cur.getX();
            int curY = cur.getY();

            // 4ë°©í–¥ íƒìƒ‰í•´ì„œ
            for (int d = 0; d < 4; d++) {
                int nextX = curX + moveX[d];
                int nextY = curY + moveY[d];

                // ë‹¤ìŒ ì¢Œí‘œì˜ ê°’ì´ ë²”ìœ„ ì´ë‚´ì´ê³ , ê°’ì´ 0ì´ë¼ë©´
                if (isAvailable(nextX, nextY, graph)) {
                    graph[nextX][nextY] = 2; // ë°”ì´ëŸ¬ìŠ¤ ì „ì—¼ì‹œí‚¤ê¸°
                    queue.offer(new Coordinates(nextX, nextY)); // í•´ë‹¹ ì¢Œí‘œ íì— ì¶”ê°€ BFS
                }
            }
        }

        // BFSê°€ ëë‚ ë•Œë§ˆë‹¤ ì•ˆì „ ì˜ì—­ í¬ê¸° ì°¾ê¸°
        getSafeArea(graph);
    }

    public static void getSafeArea(int[][] graph) {
        int count = 0;
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph[i].length; j++) {
                if (graph[i][j] == 0) { // 0 : ì•ˆì „ ì˜ì—­ ê°œìˆ˜ ì¹´ìš´íŒ…
                    count++;
                }
            }
        }

        // ì•ˆì „ ì˜ì—­ ê°œìˆ˜ ì¤‘ ìµœëŒ“ê°’ êµ¬í•˜ê¸°
        answer = Math.max(answer, count);
    }

    // ë²”ìœ„ ì²´í¬ (ë²”ìœ„ ì´ë‚´ì´ë©°, ë¹ˆì¹¸ì¸ ê²½ìš° true)
    public static boolean isAvailable(int x, int y, int[][] graph) {
        if (x >= 0 && x < graph.length && y >= 0 && y < graph[x].length && graph[x][y] == 0) {
            return true;
        }

        return false;
    }
}
```